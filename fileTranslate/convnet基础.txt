翻译http://cs231n.github.io/convolutional-networks/#architectures 部分
Number of filters K
,
their spatial extent F
,
the stride S
,
the amount of zero padding P
.
将fc层变为卷积层：
fc层和卷积层的唯一区别是卷积层的神经元只连接了输入的局部感受野，而且很多卷积层共享参数。然而，神经元在两者中，都计算点乘，因此，它们的功能是一致的。因此，fc层和卷积层之间的转换也是可能的。
	对于任意一个卷积层，都有一个fc层完成同样的前向传播功能。其中权重矩阵将是一个很大的矩阵，而且除了一些相同的局部感受野部分，其它地方都是0。
	相对的，任何fc层都能能转化成卷积层。比如，一个接收输入为7*7*512，深度k=4096的fc层可以用一个长度f为7，填充p为0，移动步数s为1，深度k为4096的卷积层代替。换句话说，我们把卷积层的大小设置为输入数据的尺寸，因此输出就是1*1*4096，因为卷积层只在输入层中匹配运算一次，和fc结果一样。
fc层到卷积层的转化。在这两种转化中，fc层到卷积层的转化在实际中尤其有用。比如说一个卷积网络，输入为224*224*3，使用一系列卷积层和池化层，最终把图片的结构减少为7*7*512.（在接下来要看到的alexnet结构中，这是通过使用5个池化层来对输入进行参数为2的下采样来实现的，最终结构为224/2/2/2/2/2 = 7）。从这里之后，alexnet使用两个大小为4096的fc层，然后最终用一个1000个神经元的fc层来计算最终分类结果。我们可以将这三个fc层的每一个按照下述方式转化为卷积层：
	对于第一个接收7*7*512的fc层，可以用卷积大小为7的卷积层，深度为4096，输出为1*1*4096.
	对于第二个fc层，可以用卷积大小为1的卷积层，深度为4096，输出为1*1*4096.
	对于第三个fc层，可以用卷积大小为1的卷积层，深度为1000，输出为1*1*1000.
fc层到卷积层的转换，实际可以包括改变权重矩阵的形状。于是这种转变让我们可以将最初的卷积网络在一个前向传播中降维。

比如，如果一个224*224的图片上，使用7*7*512的卷积，维度减少32倍，那么对于384*384的图片，维度减少相同倍数的话，需要使用12*12*512的卷积层，因为384/32=12。之后使用3个之前提到的从fc层转化的卷积层，将会得到6*6*1000的输出，因为（12-7）／1 + 1 = 6.注意，我们现在从384*384的图片得到了6*6个分类得分结果数组，而不是一个1*1*1000的得分结果结构。